<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AESNote</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>tailwind.config = { darkMode: 'class' }</script>
    <link rel="stylesheet" href="./src/style.css">
</head>
<body class="bg-gray-100 text-gray-900 dark:bg-gray-900 dark:text-white">
    <!-- Top Banner -->
    <header class="bg-blue-600 text-white p-2 fixed top-0 left-0 right-0 z-10">
        <div class="flex justify-between items-center">
            <div class="text-xl font-bold">AESNote</div>
            <div id="breadcrumb" class="flex-1 text-center">No directory selected</div>
            <div id="headerButtons" class="space-x-2">
                <button id="newBtn" class="bg-blue-500 hover:bg-blue-700 px-4 py-2 rounded">New</button>
                <button id="openBtn" class="bg-blue-500 hover:bg-blue-700 px-4 py-2 rounded">Open</button>
                <button id="saveBtn" class="bg-blue-500 hover:bg-blue-700 px-4 py-2 rounded">Save</button>
                <button id="saveAsBtn" class="bg-blue-500 hover:bg-blue-700 px-4 py-2 rounded">Save As</button>
                <button id="deleteBtn" class="bg-red-500 hover:bg-red-700 px-4 py-2 rounded" style="display: none;">Delete</button>
                <button id="menuBtn" class="bg-blue-500 hover:bg-blue-700 px-4 py-2 rounded">Menu</button>

                <!-- Compact dropdown menu (used when header is too narrow) -->
                <div id="compactMenu" aria-hidden="true">
                    <button id="compactNew">New</button>
                    <button id="compactOpen">Open</button>
                    <button id="compactSave">Save</button>
                    <button id="compactSaveAs">Save As</button>
                    <button id="compactToggleTheme">Toggle Theme</button>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div id="mainContent" class="flex h-screen dark:bg-gray-800">
        <!-- Sidebar -->
        <aside id="sidebar" class="w-64 bg-gray-200 p-4 overflow-y-auto dark:bg-black dark:text-white">
            <h3 class="text-lg font-semibold mb-4">Files</h3>
            <ul id="fileList" class="space-y-2"></ul>
        </aside>

        <!-- Editor -->
        <main class="flex-1 p-1">
            <div class="mb-2 space-x-2 dark:bg-black">
                <button onclick="document.execCommand('bold')" class="bg-gray-200 px-3 py-1 rounded dark:bg-black dark:text-white">B</button>
                <button onclick="document.execCommand('italic')" class="bg-gray-200 px-3 py-1 rounded dark:bg-black dark:text-white">I</button>
                <button onclick="document.execCommand('underline')" class="bg-gray-200 px-3 py-1 rounded dark:bg-black dark:text-white">U</button>
                <button onclick="insertUnorderedList()" class="bg-gray-200 px-3 py-1 rounded dark:bg-black dark:text-white">•</button>
                <button onclick="insertOrderedList()" class="bg-gray-200 px-3 py-1 rounded dark:bg-black dark:text-white">1.</button>
            </div>
            <div id="editor" contenteditable="true" class="w-full h-full border border-gray-300 p-3 bg-white dark:bg-gray-800 dark:text-white rounded shadow text-lg"></div>
        </main>
    </div>

    <!-- Status Bar -->
    <footer class="bg-gray-300 p-1 fixed bottom-0 left-0 right-0 text-sm dark:bg-gray-800 dark:text-white">
        <div class="flex justify-between">
            <div id="wordCount">Words: 0 | Chars: 0</div>
            <div id="saveStatus"></div>
            <div id="securityStatus">Encryption: AES-256-GCM</div>
        </div>
    </footer>

        <!-- Password Modal -->
        <div id="passwordModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
            <div class="bg-white p-6 rounded shadow-lg">
                <h3 class="text-lg font-semibold mb-4">Enter Password <span id="passwordFileName" class="text-sm text-gray-500"></span></h3>
                <input type="password" id="passwordInput" class="border border-gray-300 p-2 w-full mb-4" placeholder="Password">
                <div class="flex justify-end space-x-2">
                    <button id="cancelBtn" class="bg-gray-500 hover:bg-gray-700 px-4 py-2 rounded">Cancel</button>
                    <button id="unlockBtn" class="bg-blue-500 hover:bg-blue-700 px-4 py-2 rounded">Unlock</button>
                </div>
            </div>
        </div>

    <script>
        // Global variables
        let directoryHandle = null;
        let currentFileHandle = null;
        let currentPassword = null;
        let isEncrypted = false;
        let db = null;
        let newFileName = null;

        // Initialize IndexedDB
        function initDB() {
            const request = indexedDB.open('AESNoteDB', 1);
            request.onupgradeneeded = (event) => {
                db = event.target.result;
                if (!db.objectStoreNames.contains('directoryHandle')) {
                    db.createObjectStore('directoryHandle');
                }
            };
            request.onsuccess = (event) => {
                db = event.target.result;
                loadDirectoryHandle();
            };
        }

        // Load directory handle from IndexedDB
        async function loadDirectoryHandle() {
            if (!db) return;
            const transaction = db.transaction(['directoryHandle'], 'readonly');
            const store = transaction.objectStore('directoryHandle');
            const request = store.get('handle');
            request.onsuccess = async () => {
                if (request.result) {
                    directoryHandle = request.result;
                    // Validate handle and permissions; request read/write permission if needed; if still invalid/denied, clear it so user re-selects
                    if (!isValidDirectoryHandle(directoryHandle) || !(await ensureDirectoryPermission(directoryHandle, 'readwrite'))) {
                        console.warn('Stored directory handle is invalid or lacks read/write permission; attempting to request permission.');
                        // Try explicit request if API supports it
                        try {
                            if (isValidDirectoryHandle(directoryHandle) && typeof directoryHandle.requestPermission === 'function') {
                                const reqPerm = await directoryHandle.requestPermission({ mode: 'readwrite' });
                                if (reqPerm === 'granted') {
                                    updateBreadcrumb();
                                    listFiles();
                                    return;
                                }
                            }
                        } catch (e) {
                            console.warn('Explicit permission request failed:', e);
                        }
                        console.warn('Stored directory handle lacks permission; please re-select directory.');
                        directoryHandle = null;
                        updateBreadcrumb();
                        return;
                    }
                    updateBreadcrumb();
                    listFiles();
                } else {
                    selectDirectory();
                }
            };
            request.onerror = () => {
                console.warn('Error reading directory handle from IndexedDB');
            };
        }

        // Save directory handle to IndexedDB (only if read/write permission is available)
        function saveDirectoryHandle() {
            if (!db || !directoryHandle) return;
            ensureDirectoryPermission(directoryHandle, 'readwrite').then(hasPerm => {
                if (!hasPerm) {
                    console.warn('Not saving directory handle because read/write permission not granted.');
                    return;
                }
                const transaction = db.transaction(['directoryHandle'], 'readwrite');
                const store = transaction.objectStore('directoryHandle');
                const req = store.put(directoryHandle, 'handle');
                req.onsuccess = () => console.log('Directory handle saved to IndexedDB');
                req.onerror = (e) => console.warn('Failed to save directory handle:', e);
            }).catch(e => console.warn('Failed to verify permission before saving handle', e));
        }

        // Attempt to request read/write permission for an existing persisted directory handle
        async function requestDirectoryAccess() {
            if (!directoryHandle) {
                // No persisted handle; fall back to asking the user to select one
                await selectDirectory();
                return;
            }
            try {
                // First, check if we already have permission
                let hasPerm = await ensureDirectoryPermission(directoryHandle, 'readwrite');
                if (!hasPerm && typeof directoryHandle.requestPermission === 'function') {
                    const resp = await directoryHandle.requestPermission({ mode: 'readwrite' });
                    hasPerm = resp === 'granted';
                }
                if (hasPerm) {
                    saveDirectoryHandle();
                    updateBreadcrumb();
                    listFiles();
                    document.getElementById('saveStatus').textContent = 'Access granted for directory';
                    setTimeout(() => document.getElementById('saveStatus').textContent = '', 3000);
                    return true;
                } else {
                    alert('Directory access (read/write) was not granted. Some operations will remain disabled.');
                    updateBreadcrumb();
                    return false;
                }
            } catch (e) {
                console.warn('requestDirectoryAccess failed:', e);
                alert('Failed to request directory access: ' + (e.message || e.name || e));
                return false;
            }
        }

        // Helper to validate directory handle
        function isValidDirectoryHandle(handle) {
            return handle && typeof handle.getFileHandle === 'function';
        }

        // Helper to validate file handle
        function isValidFileHandle(handle) {
            return handle && typeof handle.getFile === 'function' && typeof handle.createWritable === 'function';
        }

        // Ensure we have permission to access/write the directory
        async function ensureDirectoryPermission(dirHandle, mode = 'readwrite') {
            if (!dirHandle || !isValidDirectoryHandle(dirHandle)) return false;
            // Some browsers may not expose queryPermission/requestPermission on handles
            const options = { mode };
            try {
                if (typeof dirHandle.queryPermission === 'function') {
                    const perm = await dirHandle.queryPermission(options);
                    if (perm === 'granted') return true;
                }
                if (typeof dirHandle.requestPermission === 'function') {
                    const req = await dirHandle.requestPermission(options);
                    return req === 'granted';
                }
                // If the methods don't exist, we can't verify; assume it's usable
                return true;
            } catch (e) {
                console.warn('Permission check failed:', e);
                return false;
            }
        }

        // Ensure we have permission to access/read a file handle
        async function ensureFilePermission(fileHandle, mode = 'read') {
            if (!fileHandle || !isValidFileHandle(fileHandle)) return false;
            const options = { mode };
            try {
                if (typeof fileHandle.queryPermission === 'function') {
                    const perm = await fileHandle.queryPermission(options);
                    if (perm === 'granted') return true;
                }
                if (typeof fileHandle.requestPermission === 'function') {
                    const req = await fileHandle.requestPermission(options);
                    return req === 'granted';
                }
                return true;
            } catch (e) {
                console.warn('File permission check failed:', e);
                return false;
            }
        }

        // Crypto functions
        async function deriveKey(password, salt) {
            const keyMaterial = await crypto.subtle.importKey(
                'raw',
                new TextEncoder().encode(password),
                'PBKDF2',
                false,
                ['deriveBits', 'deriveKey']
            );
            return crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: salt,
                    iterations: 600000,
                    hash: 'SHA-256'
                },
                keyMaterial,
                { name: 'AES-GCM', length: 256 },
                false,
                ['encrypt', 'decrypt']
            );
        }

        async function encrypt(data, password) {
            const salt = crypto.getRandomValues(new Uint8Array(16));
            const key = await deriveKey(password, salt);
            const iv = crypto.getRandomValues(new Uint8Array(12));
            const encrypted = await crypto.subtle.encrypt(
                { name: 'AES-GCM', iv: iv },
                key,
                data
            );
            return new Uint8Array([...salt, ...iv, ...new Uint8Array(encrypted)]);
        }

        async function decrypt(encryptedData, password) {
            const salt = encryptedData.slice(0, 16);
            const iv = encryptedData.slice(16, 28);
            const ciphertext = encryptedData.slice(28);
            const key = await deriveKey(password, salt);
            const decrypted = await crypto.subtle.decrypt(
                { name: 'AES-GCM', iv: iv },
                key,
                ciphertext
            );
            return new Uint8Array(decrypted);
        }

        // File operations
        async function selectDirectory() {
            try {
                const handle = await window.showDirectoryPicker();
                // Ensure we have read/write permission for the selected directory
                const hasPerm = await ensureDirectoryPermission(handle, 'readwrite');
                if (!hasPerm) {
                    // Try explicit request if available
                    if (typeof handle.requestPermission === 'function') {
                        const req = await handle.requestPermission({ mode: 'readwrite' });
                        if (req !== 'granted') {
                            alert('Directory access (read/write) was not granted. Please grant permission to read and write files.');
                            updateBreadcrumb();
                            return;
                        }
                    } else {
                        // Fallback: warn about potential limited functionality
                        alert('Directory selected but browser did not grant explicit read/write permission. Some operations may fail.');
                    }
                }
                directoryHandle = handle;
                saveDirectoryHandle();
                updateBreadcrumb();
                listFiles();
            } catch (error) {
                console.error('Error selecting directory:', error);
            }
        }

        async function selectFile() {
            try {
                // If no directory is selected, prompt the user to choose one first.
                if (!directoryHandle || !isValidDirectoryHandle(directoryHandle)) {
                    await selectDirectory();
                    // If the user canceled directory selection, give a clear status and stop
                    if (!directoryHandle) {
                        document.getElementById('saveStatus').textContent = 'Open canceled: no directory selected';
                        setTimeout(() => document.getElementById('saveStatus').textContent = '', 3000);
                        return;
                    }
                    // Ensure we have read permission for the chosen directory
                    const canRead = await ensureDirectoryPermission(directoryHandle, 'read');
                    if (!canRead) {
                        document.getElementById('saveStatus').textContent = 'Open canceled: read permission denied for selected directory';
                        setTimeout(() => document.getElementById('saveStatus').textContent = '', 4000);
                        return;
                    }
                }

                const options = {
                    types: [
                        { description: 'Encrypted notes', accept: { 'application/octet-stream': ['.ptxt'] } },
                        { description: 'Plain text files', accept: { 'text/plain': ['.txt'] } }
                    ]
                };
                // Now safe to start in the selected directory
                if (directoryHandle && isValidDirectoryHandle(directoryHandle)) {
                    options.startIn = directoryHandle;
                }
                const [fileHandle] = await window.showOpenFilePicker(options);
                console.log('File selected:', fileHandle.name);
                currentFileHandle = fileHandle;
                loadFile(fileHandle);
            } catch (error) {
                console.error('Error selecting file:', error);
                document.getElementById('saveStatus').textContent = 'Failed to open file: ' + (error.message || error.name || 'Unknown error');
                setTimeout(() => document.getElementById('saveStatus').textContent = '', 4000);
            }
        }

        async function listFiles() {
            if (!directoryHandle) return;
            const fileList = document.getElementById('fileList');
            fileList.innerHTML = '';
            for await (const [name, handle] of directoryHandle.entries()) {
                if (name.endsWith('.ptxt') || name.endsWith('.txt')) {
                    const li = document.createElement('li');
                    li.textContent = name;
                    li.className = 'cursor-pointer hover:bg-gray-300 p-2 rounded';
                    li.onclick = () => loadFile(handle);
                    fileList.appendChild(li);
                }
            }
        }

        async function saveFile({ forceSaveAs = false } = {}) {
            try {
                // If user asked for Save As, clear newFileName so prompt will show
                if (forceSaveAs) {
                    newFileName = null;
                    currentFileHandle = null; // force creating/selecting a new file
                }

                if (!directoryHandle) {
                    document.getElementById('saveStatus').textContent = 'Please select a directory first';
                    setTimeout(() => document.getElementById('saveStatus').textContent = '', 3000);
                    return;
                }

                // Ensure handle is valid and we have write permission
                if (!isValidDirectoryHandle(directoryHandle)) {
                    document.getElementById('saveStatus').textContent = 'Invalid directory handle; please re-select directory';
                    setTimeout(() => document.getElementById('saveStatus').textContent = '', 3000);
                    await selectDirectory();
                    return;
                }
                // Check write permission and try to request it if not already granted
                let hasPerm = await ensureDirectoryPermission(directoryHandle, 'readwrite');
                if (!hasPerm) {
                    try {
                        if (typeof directoryHandle.requestPermission === 'function') {
                            const req = await directoryHandle.requestPermission({ mode: 'readwrite' });
                            hasPerm = req === 'granted';
                        }
                    } catch (permErr) {
                        console.warn('Explicit requestPermission failed for directory:', permErr);
                    }
                }
                if (!hasPerm) {
                    // Offer a clear path to grant access
                    document.getElementById('saveStatus').textContent = 'Write permission denied for directory. Click breadcrumb -> Grant Access to allow saving.';
                    setTimeout(() => document.getElementById('saveStatus').textContent = '', 6000);
                    updateBreadcrumb();
                    return;
                }

                // Determine password and encryption based on save type
                let password;
                let fileName = null; // declare before any use to avoid TDZ errors

                if (forceSaveAs) {
                    // Save As: prompt for filename first, then password if needed
                    const fileNameInput = prompt('Enter file name (e.g., note.ptxt for encrypted, note.txt for plain):');
                    if (!fileNameInput) {
                        document.getElementById('saveStatus').textContent = 'Save As canceled';
                        setTimeout(() => document.getElementById('saveStatus').textContent = '', 3000);
                        return;
                    }
                    if (fileNameInput.endsWith('.txt')) {
                        isEncrypted = false;
                        password = null;
                    } else {
                        isEncrypted = true;
                        password = prompt('Enter password for encryption:');
                        if (!password) {
                            document.getElementById('saveStatus').textContent = 'Save As canceled';
                            setTimeout(() => document.getElementById('saveStatus').textContent = '', 3000);
                            return;
                        }
                    }
                    fileName = fileNameInput;
                } else {
                    // Regular save or new
                    if (currentFileHandle) {
                        // Regular save: keep existing format
                        password = currentPassword;
                        fileName = currentFileHandle.name;
                    } else {
                        // New file: save as plain text
                        password = null;
                        isEncrypted = false;
                        if (newFileName) {
                            fileName = newFileName + '.txt';
                            newFileName = null;
                        } else {
                            fileName = null; // will prompt below
                        }
                    }
                }

                const content = document.getElementById('editor').innerHTML;
                let dataToSave;
                if (isEncrypted) {
                    const data = new TextEncoder().encode(content);
                    dataToSave = await encrypt(data, password);
                } else {
                    dataToSave = content;
                }

                if (!fileName) {
                    // Prompt the user for a filename if we still don't have one
                    const ext = isEncrypted ? '.ptxt' : '.txt';
                    const name = prompt(`Enter file name (without extension, will save as ${ext}):`);
                    if (!name) {
                        document.getElementById('saveStatus').textContent = 'Save canceled';
                        setTimeout(() => document.getElementById('saveStatus').textContent = '', 3000);
                        return;
                    }
                    fileName = name + ext;
                }

                // Check if file already exists and prompt for overwrite if Save As
                let fileHandle;
                try {
                    fileHandle = await directoryHandle.getFileHandle(fileName, { create: false });
                    // File exists, ask to overwrite
                    const overwrite = confirm(`File "${fileName}" already exists. Overwrite?`);
                    if (!overwrite) {
                        document.getElementById('saveStatus').textContent = 'Save As canceled';
                        setTimeout(() => document.getElementById('saveStatus').textContent = '', 3000);
                        return;
                    }
                } catch (e) {
                    // File doesn't exist, create it
                    fileHandle = await directoryHandle.getFileHandle(fileName, { create: true });
                }

                // Keep the file handle as current to enable future saves without prompting
                currentFileHandle = fileHandle;

                // Remember password for the session (only if encrypted)
                currentPassword = isEncrypted ? password : null;

                // Show delete button since file is now saved/opened
                document.getElementById('deleteBtn').style.display = 'inline-block';

                // Try to ensure file has write permission (if API supports it)
                try {
                    if (typeof fileHandle.requestPermission === 'function' || typeof fileHandle.queryPermission === 'function') {
                        const q = typeof fileHandle.queryPermission === 'function' ? await fileHandle.queryPermission({ mode: 'readwrite' }) : null;
                        if (q !== 'granted') {
                            const r = typeof fileHandle.requestPermission === 'function' ? await fileHandle.requestPermission({ mode: 'readwrite' }) : null;
                            if (r !== 'granted') {
                                document.getElementById('saveStatus').textContent = 'Write permission denied for file';
                                setTimeout(() => document.getElementById('saveStatus').textContent = '', 3000);
                                return;
                            }
                        }
                    }
                } catch (permErr) {
                    console.warn('File permission check failed:', permErr);
                }

                // Attempt to write using the file handle; if it fails, try fallback flows
                try {
                    const writable = await fileHandle.createWritable();
                    try {
                        await writable.write(dataToSave);
                    } catch (writeErr) {
                        console.warn('Direct write failed, attempting blob fallback:', writeErr);
                        try {
                            await writable.write(new Blob([dataToSave]));
                        } catch (blobErr) {
                            console.warn('Blob write also failed:', blobErr);
                            try {
                                await writable.close();
                            } catch (closeErr) { /* ignore */ }
                            throw blobErr;
                        }
                    }
                    await writable.close();
                } catch (finalErr) {
                    console.warn('Write using file handle failed:', finalErr);
                    // Fallback: attempt to ask the user to pick a save location (showSaveFilePicker), or as last resort trigger a download
                    if (typeof window.showSaveFilePicker === 'function') {
                        try {
                            const picked = await window.showSaveFilePicker({ suggestedName: fileName });
                            const w2 = await picked.createWritable();
                            await w2.write(dataToSave);
                            await w2.close();
                            currentFileHandle = picked;
                            document.getElementById('saveStatus').textContent = 'File saved (via Save dialog)';
                            setTimeout(() => document.getElementById('saveStatus').textContent = '', 3000);
                        } catch (pickerErr) {
                            console.warn('showSaveFilePicker fallback failed:', pickerErr);
                            // As a final workaround, create a download link
                            try {
                                const blob = dataToSave instanceof Blob ? dataToSave : new Blob([dataToSave]);
                                const url = URL.createObjectURL(blob);
                                const a = document.createElement('a');
                                a.href = url;
                                a.download = fileName;
                                document.body.appendChild(a);
                                a.click();
                                a.remove();
                                URL.revokeObjectURL(url);
                                document.getElementById('saveStatus').textContent = 'Download started (could not save to disk)';
                                setTimeout(() => document.getElementById('saveStatus').textContent = '', 4000);
                            } catch (dlErr) {
                                console.error('Final fallback (download) failed:', dlErr);
                                document.getElementById('saveStatus').textContent = 'Save failed: ' + (dlErr.message || dlErr.name || 'Unknown error');
                                setTimeout(() => document.getElementById('saveStatus').textContent = '', 5000);
                                throw dlErr;
                            }
                        }
                    } else {
                        // Browser does not support save picker; fall back to download
                        try {
                            const blob = dataToSave instanceof Blob ? dataToSave : new Blob([dataToSave]);
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = fileName;
                            document.body.appendChild(a);
                            a.click();
                            a.remove();
                            URL.revokeObjectURL(url);
                            document.getElementById('saveStatus').textContent = 'Download started (could not save to disk)';
                            setTimeout(() => document.getElementById('saveStatus').textContent = '', 4000);
                        } catch (dlErr) {
                            console.error('Download fallback failed:', dlErr);
                            document.getElementById('saveStatus').textContent = 'Save failed: ' + (dlErr.message || dlErr.name || 'Unknown error');
                            setTimeout(() => document.getElementById('saveStatus').textContent = '', 5000);
                            throw dlErr;
                        }
                    }
                }
                // Update the current file label to reflect the new file name
                const lbl = document.getElementById('currentFileLabel');
                if (lbl) lbl.textContent = `/${fileName}`;
                updateSecurityStatus();
                listFiles();
                document.getElementById('saveStatus').textContent = 'File saved';
                setTimeout(() => document.getElementById('saveStatus').textContent = '', 3000);
            } catch (error) {
                console.error('Error saving file:', error.name || error, error.message || error);
                document.getElementById('saveStatus').textContent = 'Save failed: ' + (error.message || error.name || 'Unknown error');
                setTimeout(() => document.getElementById('saveStatus').textContent = '', 5000);
            }
        }

        // Save As convenience
        document.getElementById('saveAsBtn').onclick = () => saveFile({ forceSaveAs: true });

        // Delete file
        async function deleteFile() {
            if (!currentFileHandle || !directoryHandle) return;
            const confirmed = confirm(`Are you sure you want to delete "${currentFileHandle.name}"?`);
            if (!confirmed) return;
            try {
                await directoryHandle.removeEntry(currentFileHandle.name);
                document.getElementById('editor').innerHTML = '';
                currentFileHandle = null;
                currentPassword = null;
                isEncrypted = false;
                updateWordCount();
                updateSecurityStatus();
                document.getElementById('deleteBtn').style.display = 'none';
                const lbl = document.getElementById('currentFileLabel');
                if (lbl) lbl.textContent = '';
                listFiles();
                document.getElementById('saveStatus').textContent = 'File deleted';
                setTimeout(() => document.getElementById('saveStatus').textContent = '', 3000);
            } catch (error) {
                console.error('Error deleting file:', error);
                document.getElementById('saveStatus').textContent = 'Delete failed: ' + (error.message || error.name || 'Unknown error');
                setTimeout(() => document.getElementById('saveStatus').textContent = '', 5000);
            }
        }

        async function loadFile(fileHandle) {
            currentFileHandle = fileHandle;

            // Validate file handle first
            if (!isValidFileHandle(currentFileHandle)) {
                console.error('Invalid file handle passed to loadFile', currentFileHandle);
                document.getElementById('saveStatus').textContent = 'Invalid file handle. Please re-open file.';
                setTimeout(() => document.getElementById('saveStatus').textContent = '', 4000);
                // clear file name displays
                const lbl = document.getElementById('currentFileLabel'); if (lbl) lbl.textContent = '';
                const pfn = document.getElementById('passwordFileName'); if (pfn) pfn.textContent = '';
                return;
            }

            // Ensure we have read permission for the file; request it if possible
            try {
                const canRead = await ensureFilePermission(currentFileHandle, 'read');
                if (!canRead) {
                    if (typeof currentFileHandle.requestPermission === 'function') {
                        const req = await currentFileHandle.requestPermission({ mode: 'read' });
                        if (req !== 'granted') {
                            document.getElementById('saveStatus').textContent = 'Read permission denied for file. Click breadcrumb -> Grant Access to allow reading files.';
                            setTimeout(() => document.getElementById('saveStatus').textContent = '', 6000);
                            updateBreadcrumb();
                            // clear file name displays
                            const lbl = document.getElementById('currentFileLabel'); if (lbl) lbl.textContent = '';
                            const pfn = document.getElementById('passwordFileName'); if (pfn) pfn.textContent = '';
                            return;
                        }
                    } else {
                        document.getElementById('saveStatus').textContent = 'Read permission denied for file. Use the breadcrumb Grant Access button.';
                        setTimeout(() => document.getElementById('saveStatus').textContent = '', 6000);
                        updateBreadcrumb();
                        // clear file name displays
                        const lbl = document.getElementById('currentFileLabel'); if (lbl) lbl.textContent = '';
                        const pfn = document.getElementById('passwordFileName'); if (pfn) pfn.textContent = '';
                        return;
                    }
                }
            } catch (e) {
                console.warn('File permission check failed', e);
                document.getElementById('saveStatus').textContent = 'Permission check failed. Try granting access via the breadcrumb.';
                setTimeout(() => document.getElementById('saveStatus').textContent = '', 6000);
                updateBreadcrumb();
                return;
            }

            // Safe to set file name for UI
            try {
                document.getElementById('passwordFileName').textContent = `(${fileHandle.name})`;
                const lbl = document.getElementById('currentFileLabel');
                if (lbl) lbl.textContent = `/${fileHandle.name}`;
                document.getElementById('deleteBtn').style.display = 'inline-block';
            } catch (e) {
                // ignore if elements not present
            }

            if (fileHandle.name.endsWith('.txt')) {
                isEncrypted = false;
                try {
                    const file = await fileHandle.getFile();
                    const content = await file.text();
                    const editor = document.getElementById('editor');
                    editor.innerHTML = content;
                    editor.focus();
                    editor.scrollTop = 0;
                    currentPassword = null;
                    updateWordCount();
                    updateSecurityStatus();
                    document.getElementById('saveStatus').textContent = 'File loaded (plain text)';
                    setTimeout(() => document.getElementById('saveStatus').textContent = '', 3000);
                } catch (error) {
                    console.error('Error loading plain text file:', error);
                    document.getElementById('saveStatus').textContent = 'Failed to load plain text file: ' + (error.message || error.name || 'Unknown error');
                    setTimeout(() => document.getElementById('saveStatus').textContent = '', 5000);
                }
            } else {
                isEncrypted = true;
                document.getElementById('passwordModal').classList.remove('hidden');
            }
        }

        async function unlockFile() {
            const password = document.getElementById('passwordInput').value;
            if (!password) return;
            try {
                if (!currentFileHandle || !isValidFileHandle(currentFileHandle)) {
                    throw new Error('Invalid file handle');
                }
                const canRead = await ensureFilePermission(currentFileHandle, 'read');
                if (!canRead) {
                    throw new Error('Read permission denied for file');
                }
                const file = await currentFileHandle.getFile();
                const encryptedData = new Uint8Array(await file.arrayBuffer());
                const decrypted = await decrypt(encryptedData, password);
                console.log('Decrypted bytes length:', decrypted.length);
                const content = new TextDecoder().decode(decrypted);
                console.log('Decrypted content preview:', content.slice(0, 200));

                // If file appears empty after decryption, notify the user clearly
                if (!content || content.trim().length === 0) {
                    document.getElementById('editor').innerHTML = '';
                    document.getElementById('passwordModal').classList.add('hidden');
                    document.getElementById('passwordInput').value = '';
                    updateWordCount();
                    document.getElementById('saveStatus').textContent = 'File unlocked (empty content)';
                    setTimeout(() => document.getElementById('saveStatus').textContent = '', 4000);
                    console.warn('File decrypted successfully but content is empty');
                    return;
                }

                // Set editor content and focus it so the user sees it immediately
                const editor = document.getElementById('editor');
                editor.innerHTML = content;
                editor.focus();
                editor.scrollTop = 0;

                document.getElementById('passwordModal').classList.add('hidden');
                // Always remember password for the session
                currentPassword = password;
                isEncrypted = true;
                // Keep currentFileHandle (so Save will overwrite it)
                document.getElementById('passwordInput').value = '';
                updateWordCount();
                updateSecurityStatus();
                document.getElementById('saveStatus').textContent = 'File unlocked';
                setTimeout(() => document.getElementById('saveStatus').textContent = '', 3000);
            } catch (error) {
                console.error('Error unlocking file:', error);
                document.getElementById('saveStatus').textContent = 'Unlock failed: ' + (error.message || error.name || 'Unknown error');
                setTimeout(() => document.getElementById('saveStatus').textContent = '', 5000);
                alert('Incorrect password or corrupted file.');
            }
        }

        // UI functions
        function updateBreadcrumb() {
            const breadcrumb = document.getElementById('breadcrumb');
            // Note: browsers intentionally do not expose full OS paths for privacy/security.
            // We display the folder name and a helpful tooltip instead.
            breadcrumb.innerHTML = '';
            if (directoryHandle && directoryHandle.name) {
                breadcrumb.innerHTML = `<span title="Full path not available in browser; showing folder name only">${directoryHandle.name}</span> <span id="currentFileLabel" class="ml-2 text-sm text-gray-200"></span>`;
                const btn = document.getElementById('selectDirBtn');
                if (btn) btn.remove();

                // Asynchronously verify permissions and show a Grant Access button if needed
                (async () => {
                    try {
                        const canRead = await ensureDirectoryPermission(directoryHandle, 'read');
                        const existingGrantBtn = document.getElementById('grantAccessBtn');
                        if (!canRead) {
                            if (!existingGrantBtn) {
                                const gbtn = document.createElement('button');
                                gbtn.id = 'grantAccessBtn';
                                gbtn.className = 'ml-2 bg-yellow-500 hover:bg-yellow-700 px-3 py-1 rounded text-white';
                                gbtn.textContent = 'Grant Access';
                                gbtn.onclick = async () => { await requestDirectoryAccess(); };
                                breadcrumb.appendChild(gbtn);
                            }
                        } else {
                            if (existingGrantBtn) existingGrantBtn.remove();
                        }
                    } catch (e) {
                        console.warn('Permission check in updateBreadcrumb failed', e);
                    }
                })();
            } else {
                breadcrumb.innerHTML = '';
                // Create a clear button to prompt the user to select a directory
                const btn = document.createElement('button');
                btn.id = 'selectDirBtn';
                btn.className = 'bg-blue-500 hover:bg-blue-700 px-3 py-1 rounded text-white';
                btn.textContent = 'No directory selected — Click to select';
                btn.onclick = async () => {
                    await selectDirectory();
                    // after selecting, ensure we update breadcrumb and list files
                    updateBreadcrumb();
                };
                breadcrumb.appendChild(btn);
            }
        }

        function updateWordCount() {
            const content = document.getElementById('editor').textContent;
            const words = content.trim().split(/\s+/).filter(word => word.length > 0).length;
            const chars = content.length;
            document.getElementById('wordCount').textContent = `Words: ${words} | Chars: ${chars}`;
        }

        function updateSecurityStatus() {
            const status = isEncrypted ? 'Encryption: AES-256-GCM' : 'Plain text';
            document.getElementById('securityStatus').textContent = status;
        }

        function insertUnorderedList() {
            document.getElementById('editor').focus();
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;
            const range = selection.getRangeAt(0);
            if (range.collapsed) {
                document.execCommand('insertHTML', false, '<ul><li><br></li></ul>');
            } else {
                const selectedText = range.toString();
                document.execCommand('insertHTML', false, '<ul><li>' + selectedText + '</li></ul>');
            }
        }

        function insertOrderedList() {
            document.getElementById('editor').focus();
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;
            const range = selection.getRangeAt(0);
            if (range.collapsed) {
                document.execCommand('insertHTML', false, '<ol><li><br></li></ol>');
            } else {
                const selectedText = range.toString();
                document.execCommand('insertHTML', false, '<ol><li>' + selectedText + '</li></ol>');
            }
        }

        // Mobile / responsive helpers
        function isMobileDevice() {
            try {
                return /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || window.matchMedia('(max-width: 640px)').matches;
            } catch (e) {
                return false;
            }
        }

        function applyResponsiveLayout() {
            const mobile = isMobileDevice();
            const sidebarEl = document.getElementById('sidebar');
            const headerButtons = document.getElementById('headerButtons');
            const editor = document.getElementById('editor');

            if (mobile) {
                if (sidebarEl) sidebarEl.classList.add('hidden');
                if (headerButtons) {
                    headerButtons.classList.remove('space-x-2');
                    headerButtons.classList.add('flex','flex-row','justify-between','gap-2','w-full');
                    Array.from(headerButtons.querySelectorAll('button')).forEach(b => {
                        b.style.flex = '1';
                        b.style.padding = '0.5rem';
                        b.style.fontSize = '0.95rem';
                    });
                }
                if (editor) {
                    // editor height will be set by adjustLayoutSpacing() to account for header/footer size
                    editor.style.overflow = 'auto';
                }
                // Ensure breadcrumb is not overcrowded
                const breadcrumb = document.getElementById('breadcrumb');
                if (breadcrumb) breadcrumb.style.whiteSpace = 'normal';
            } else {
                if (sidebarEl) sidebarEl.classList.remove('hidden');
                if (headerButtons) {
                    headerButtons.classList.add('space-x-2');
                    headerButtons.classList.remove('flex','flex-row','justify-between','gap-2','w-full');
                    Array.from(headerButtons.querySelectorAll('button')).forEach(b => {
                        b.style.flex = '';
                        b.style.padding = '';
                        b.style.fontSize = '';
                    });
                }
                if (editor) {
                    editor.style.height = '';
                    editor.style.overflow = '';
                }
                const breadcrumb = document.getElementById('breadcrumb');
                if (breadcrumb) breadcrumb.style.whiteSpace = '';
            }
        }

        // Apply layout on initial load and when screen size/orientation changes
        function adjustLayoutSpacing() {
            try {
                const header = document.querySelector('header');
                const footer = document.querySelector('footer');
                const main = document.getElementById('mainContent');
                const editor = document.getElementById('editor');
                const headerHeight = header ? header.offsetHeight : 0;
                const footerHeight = footer ? footer.offsetHeight : 0;
                
                // Apply padding to main content so header does not overlap
                if (main) {
                    // Remove any existing padding-top first, then apply new value
                    main.style.paddingTop = '';
                    // Apply exact header height to ensure no gap
                    main.style.paddingTop = headerHeight + 'px';
                    
                    // Also ensure mainContent has proper positioning to work with fixed header
                    main.style.position = 'relative';
                    main.style.top = '0';
                    
                    // Remove any margin that might cause gaps
                    main.style.marginTop = '0';
                    
                    // Ensure no border spacing
                    main.style.borderTop = '0';
                    
                    // Force the padding to be applied by setting it again
                    main.style.paddingTop = headerHeight + 'px';
                }
                
                // Set editor height to fit between header and footer
                if (editor) {
                    const extra = 12; // small gap
                    const desired = `calc(100vh - ${headerHeight + footerHeight}px - ${extra}px)`;
                    editor.style.height = desired;
                    editor.style.overflow = 'auto';
                    console.log('Applied height to editor:', desired);
                }
            } catch (e) {
                console.warn('adjustLayoutSpacing failed', e);
            }
        }

        // Header overflow detection and compact menu handling
        function hideCompactMenu() {
            const cm = document.getElementById('compactMenu');
            if (cm) {
                cm.classList.remove('show');
                // Reset positioning when hiding
                cm.style.position = '';
                cm.style.top = '';
                cm.style.right = '';
            }
        }

        function checkHeaderOverflow() {
            try {
                const hb = document.getElementById('headerButtons');
                if (!hb) return;
                const headerDiv = hb.closest('header')?.querySelector('div.flex');
                const logo = headerDiv ? headerDiv.children[0] : null;
                const breadcrumb = headerDiv ? headerDiv.children[1] : null;
                const menuBtn = document.getElementById('menuBtn');

                // measure total width of non-dropdown children (including margins)
                let total = 0;
                Array.from(hb.children).forEach((el) => {
                    if (el.id === 'compactMenu') return; // skip dropdown
                    const r = el.getBoundingClientRect();
                    if (r && r.width) total += r.width;
                });

                const headerWidth = headerDiv ? headerDiv.getBoundingClientRect().width : window.innerWidth;
                const logoWidth = logo ? logo.getBoundingClientRect().width : 0;
                const breadcrumbWidth = breadcrumb ? breadcrumb.getBoundingClientRect().width : 0;

                // available space for buttons = header width - logo - breadcrumb - small margin
                const availableForButtons = Math.max(0, headerWidth - logoWidth - breadcrumbWidth - 24);

                // Force compact if window or header is small (user request: below 540px)
                const FORCE_THRESHOLD = 540;
                const smallScreen = window.innerWidth < FORCE_THRESHOLD || headerWidth < FORCE_THRESHOLD;

                // If total width exceeds available space, or smallScreen, enter compact mode
                if (smallScreen || total > availableForButtons) {
                    hb.classList.add('compact');
                    // Make sure only the menu is visible and switch menu to compact icon
                    if (menuBtn) {
                        menuBtn.classList.add('compact');
                        menuBtn.setAttribute('aria-label', 'Open menu (actions hidden)');
                        // If forced by threshold, show gear/wheel icon; otherwise hamburger
                        if (smallScreen) {
                            menuBtn.innerHTML = '⚙';
                        } else {
                            menuBtn.innerHTML = '&#9776;';
                        }
                    }

                    // Position only the menu button absolutely to the right corner of the header
                    if (menuBtn) {
                        menuBtn.style.position = 'absolute';
                        menuBtn.style.right = '0.75rem';
                        menuBtn.style.top = '50%';
                        menuBtn.style.transform = 'translateY(-50%)';
                        menuBtn.style.zIndex = '30';
                    }

                    // Reserve space on the breadcrumb to avoid overlap with the compact menu (64px)
                    const breadcrumbEl = document.getElementById('breadcrumb');
                    if (breadcrumbEl) {
                        breadcrumbEl.classList.add('compact-breadcrumb');
                        breadcrumbEl.style.paddingRight = '72px';
                    }
                    const fileLbl = document.getElementById('currentFileLabel'); if (fileLbl) fileLbl.classList.add('small-label');
                } else {
                    hb.classList.remove('compact');
                    hideCompactMenu();
                    if (menuBtn) {
                        menuBtn.classList.remove('compact');
                        menuBtn.setAttribute('aria-label', 'Menu');
                        menuBtn.textContent = 'Menu';
                    }
                    const breadcrumbEl = document.getElementById('breadcrumb');
                    if (breadcrumbEl) {
                        breadcrumbEl.classList.remove('compact-breadcrumb');
                        breadcrumbEl.style.paddingRight = '';
                    }
                    const fileLbl = document.getElementById('currentFileLabel'); if (fileLbl) fileLbl.classList.remove('small-label');

                    // Clear any inline positioning applied to menu button when not compact
                    if (menuBtn) {
                        menuBtn.style.position = '';
                        menuBtn.style.right = '';
                        menuBtn.style.top = '';
                        menuBtn.style.transform = '';
                        menuBtn.style.zIndex = '';
                    }
                }
            } catch (e) {
                console.warn('checkHeaderOverflow error', e);
            }
        }

        // Wire up compact menu toggle
        document.addEventListener('click', (e) => {
            const hb = document.getElementById('headerButtons');
            const cm = document.getElementById('compactMenu');
            const menuBtn = document.getElementById('menuBtn');
            if (menuBtn && menuBtn.contains(e.target)) {
                if (cm) {
                    // Position compactMenu relative to menuBtn when showing
                    if (menuBtn.classList.contains('compact')) {
                        const menuRect = menuBtn.getBoundingClientRect();
                        cm.style.position = 'fixed';
                        cm.style.top = (menuRect.bottom + 6) + 'px';
                        cm.style.right = (window.innerWidth - menuRect.right) + 'px';
                    }
                    cm.classList.toggle('show');
                }
                return;
            }
            // Hide if clicked outside
            if (cm && !cm.contains(e.target) && (!hb || !hb.contains(e.target))) {
                hideCompactMenu();
            }
        });

        // Close the compact menu when selecting an entry (also forward to main handlers)
        document.getElementById('compactNew').onclick = () => { hideCompactMenu(); document.getElementById('newBtn').click(); };
        document.getElementById('compactOpen').onclick = () => { hideCompactMenu(); document.getElementById('openBtn').click(); };
        document.getElementById('compactSave').onclick = () => { hideCompactMenu(); document.getElementById('saveBtn').click(); };
        document.getElementById('compactSaveAs').onclick = () => { hideCompactMenu(); document.getElementById('saveAsBtn').click(); };
        document.getElementById('compactToggleTheme').onclick = () => { hideCompactMenu(); toggleTheme(); };

        // Run both responsive layout and spacing adjustments together
        const applyLayout = () => {
            applyResponsiveLayout();
            adjustLayoutSpacing();
            checkHeaderOverflow();
        };
        window.addEventListener('load', applyLayout);
        window.addEventListener('resize', applyLayout);
        window.addEventListener('orientationchange', applyLayout);
        
        // Initial layout will be handled by the load event listener

        // Event listeners
        document.getElementById('openBtn').onclick = selectFile;
        document.getElementById('saveBtn').onclick = saveFile;
        document.getElementById('deleteBtn').onclick = deleteFile;
        document.getElementById('newBtn').onclick = () => {
            const name = prompt('Enter file name (without extension):');
            if (name) {
                newFileName = name;
                document.getElementById('editor').innerHTML = '';
                currentFileHandle = null;
                currentPassword = null;
                isEncrypted = false; // default to plain, will be set on save
                updateWordCount();
                updateSecurityStatus();
                const lbl = document.getElementById('currentFileLabel'); if (lbl) lbl.textContent = `/${name}`;
                document.getElementById('deleteBtn').style.display = 'none';
            }
        };
        document.getElementById('unlockBtn').onclick = unlockFile;
        document.getElementById('cancelBtn').onclick = () => {
            document.getElementById('passwordModal').classList.add('hidden');
            document.getElementById('passwordInput').value = '';
            const pfn = document.getElementById('passwordFileName'); if (pfn) pfn.textContent = '';
            const lbl = document.getElementById('currentFileLabel'); if (lbl) lbl.textContent = '';
            document.getElementById('deleteBtn').style.display = 'none';
        };
        document.getElementById('editor').oninput = updateWordCount;

        // Settings
        function loadSettings() {
            const theme = localStorage.getItem('theme') || 'light';
            document.body.classList.toggle('dark', theme === 'dark');
        }

        function toggleTheme() {
            const current = localStorage.getItem('theme') || 'light';
            const newTheme = current === 'light' ? 'dark' : 'light';
            localStorage.setItem('theme', newTheme);
            loadSettings();
        }

        // Update loadFile to store last file
        const originalLoadFile = loadFile;
        loadFile = async (fileHandle) => {
            await originalLoadFile(fileHandle);
            localStorage.setItem('lastFile', fileHandle.name);
        };

        // Menu button: main click handled by the compact-menu toggle; theme toggle is now available inside the compact menu
        document.getElementById('menuBtn').onclick = () => { /* no-op (menu handled by compact menu) */ };

        // Initialize
        initDB();
        loadSettings();
        updateWordCount();
        updateSecurityStatus();

        // If no directory is selected after a short delay, show a friendly prompt in the status area
        setTimeout(() => {
            if (!directoryHandle) {
                const s = document.getElementById('saveStatus');
                s.textContent = 'No directory selected — click the breadcrumb to choose a folder';
                // leave message visible for a while but keep it gentle
                setTimeout(() => { if (s.textContent === 'No directory selected — click the breadcrumb to choose a folder') s.textContent = ''; }, 7000);
            }
        }, 1000);
    </script>
</body>
</html>